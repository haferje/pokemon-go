<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<meta name="description" content="">
		<meta name="author" content="">
		<link rel="icon" href="">

		<title>Pokemon Go Viewer</title>

		<!-- vendor styles -->
		<link href="https://unpkg.com/tabulator-tables@4.2.0/dist/css/tabulator.min.css" rel="stylesheet">

		<!-- vendor scripts -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.min.js"></script>
		<script src="https://unpkg.com/tabulator-tables@4.2.0/dist/js/tabulator.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

		<!-- data scripts -->
		<script src="data/pokemon.js"></script>
		<script src="data/moves.js"></script>
		<script src="data/types.js"></script>
		<script src="data/flavors.js"></script>
		<script src="data/released.js"></script>
		<script src="data/shinies.js"></script>
		<script src="data/exclusives.js"></script>
		<script src="data/dittos.js"></script>
		<script src="data/weathers.js"></script>

		<!-- styles -->
		<style>
			.type {
				display: inline-block;
				padding: 3px;
				border-radius: 3px;
				margin-right: 1px;
			}
			.type__xx{
				border: 1px solid black; /* in case browser doesn't understand rgba */
				border: 1px solid rgba(0, 0, 0, .5);
				/* ensure the border remains transparent even if a solid background color is applied */
				-webkit-background-clip: padding-box; /* for Safari */
				background-clip: padding-box; /* for IE9+, Firefox 4+, Opera, Chrome */
			}
			.type.type-bug		{ background-color: #9cb820; }
			.type.type-dark		{ background-color: #504843; }
			.type.type-dragon	{ background-color: #7038f8; }
			.type.type-electric	{ background-color: #f8d030; }
			.type.type-fairy	{ background-color: #f09ad9; }
			.type.type-fighting	{ background-color: #c03028; }
			.type.type-fire		{ background-color: #f08030; }
			.type.type-flying	{ background-color: #9096f0; }
			.type.type-ghost	{ background-color: #705898; }
			.type.type-grass	{ background-color: #22c02a; }
			.type.type-ground	{ background-color: #e0b668; }
			.type.type-ice		{ background-color: #98d8d8; }
			.type.type-normal	{ background-color: #a8a8a8; }
			.type.type-poison	{ background-color: #a040a0; }
			.type.type-psychic	{ background-color: #f85888; }
			.type.type-rock		{ background-color: #b8a038; }
			.type.type-steel	{ background-color: #6d8f9c; }
			.type.type-water	{ background-color: #6890f0; }

			.move.legacy { background-color: yellow; }

			img.photo {
				max-height: 64px;
				width: auto;
				height: auto;
			}
		</style>

		<!-- app scripts -->
		<script>

			/* TODO
				- no sorting on list columns
				- writer filter matcher for list columns
				- try combining all data into super object, first
				- nested tables / row formatter for evolutions
				- Tabulator BUG: in row grouping, you have to click exactly on the icon to expand/contract

	regional
#	shiny
	found in egg ?
	mega
	baby
	series
	generation
#	released ?
-	evolve cost
-	evolve item
	forms
-	attack type matrix

pokemon
-	"candyCost":
-	"costToEvolve":
-	"evolutionItem":
-	"forms":
#	"legacy":
#	"rarity":

types
	"attackScalar":
	"damage":
	"id":
	"name":

moves
	"accuracyChange":
	"animationId":
	"criticalChance":
	"damageWindowEndMs":
	"damageWindowStartMs":
	"durationMs":
	"energyDelta":
	"id":
	"internalId":
	"name":
	"pokemonType":
	"power":
	"staminaLossScalar":
	"trainerLevelMax":
	"trainerLevelMin":
	"vfxName":

			*/

			Tabulator.prototype.extendModule('format', 'formatters', {
				list: function(cell, formatterParams) {
					return cell.getValue().join('<br/>');
				},
				moves: function(cell, formatterParams) {
					var html = _.map(cell.getValue(), move => {
						return `<div class="move ${move.legacy && "legacy"}">${move.name}</div>`;
					});
					return html.join('');
				},
				percent: function(cell, formatterParams) {
					return (cell.getValue() * 100).toFixed(1) + ' %';
				},
				distance: function(cell, formatterParams) {
					return cell.getValue() + ' km';
				},
				types: function(cell, formatterParams) {
					var types = cell.getValue();
					return _.map(types, 'name').join('<br/>');
				},
			});

			pokemon = _.map(pokemon, poke => {
				// TODO: damage
				var pokeTypes = _.filter(types, t => _.includes(_.map(poke.types, 'id'), t.id));
				var pokeTypeNames = _.map(pokeTypes, 'name');
				// TODO: types, damage
				var pokeQuick = _.filter(moves, quick => _.includes(_.map(poke.quickMoves, 'id'), quick.id));
				// TODO: types, damage
				var pokeCharge = _.filter(moves, charge => _.includes(_.map(poke.cinematicMoves, 'id'), charge.id));
				var pokeFlavor = _.defaultTo(flavors[poke.id], null);
				var pokeExclusive = _.defaultTo(exclusives[poke.dex], null);
				var pokeShiny = _.defaultTo(shinies[poke.dex], null);

				return {
					id          : poke.id,
					dex         : poke.dex,
					name        : poke.name,
					family      : poke.family.name,
					maxCP       : poke.maxCP,
					buddy       : poke.kmBuddyDistance,
					attack      : poke.stats.baseAttack,
					defense     : poke.stats.baseDefense,
					stamina     : poke.stats.baseStamina,
					flee        : _.get(poke, 'encounter.baseFleeRate', 0),
					capture     : _.get(poke, 'encounter.baseCaptureRate', 0),
					male        : _.get(poke, 'encounter.gender.malePercent', 0),
					female      : _.get(poke, 'encounter.gender.femalePercent', 0),
					rarity      : _.get(poke, 'rarity.name'),
					photo       : `img/${('00'+poke.dex).slice(-3)}.png`,
					// external
					category    : _.get(flavors, [poke.id, 'category'], null),
					description : _.get(flavors, [poke.id, 'description'], null),
					ditto       : _.has(dittos, poke.dex),
					released    : _.has(released, poke.dex),
					weather     : _.keys(_.pickBy(weathers, type => _.intersection(type, pokeTypeNames).length)),
					// objects
					exclusive   : pokeExclusive,
					shiny       : pokeShiny,
					// object arrays
					types       : pokeTypes,
					quicks      : pokeQuick,
					charges     : pokeCharge,
					evolutions  : poke.evolution, // will be overwritten after pokemon are established
					// BUG : cannot be null or empty array
				};
			});

			// evolutions
			// rewrite evolutions to single depth pointer references
			_.each(pokemon, poke => {
				if (!poke.evolutions.futureBranches)
					return poke.evolutions = undefined;

				_.each(poke.evolutions.futureBranches, (branch, idx, branches) => {
					branches[idx] = {
						pokemon: _.find(pokemon, { id: branch.id }),
						candy: branch.costToEvolve,
						item: _.get('branch.costToEvolve.evolutionItem.name', null),
					};
				});
			});

			// // from pokedex
			// var uncaught = [201,214,235,254,257,272,282,291,313,321,324,326,330,352,357,362,366,367,368,369,373,376,380,385,389,391,392,394,395,397,398,400,402,404,405,407,409,410,411,412,413,414,416,417,419,420,421,422,423,424,426,428,429,430,431,433,435,437,438,439,440,441,443,444,445,446,447,448,449,452,454,455,456,457,458,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,486,809];
			// // from https://serebii.net/pokemongo/pokemon.shtml
			// //var unreleased = [235,352,366,367,368,385,412,413,414,420,421,422,423,439,443,444,445,449,450,462,470,471,476,479,480,481,482,483,486,489,490,491,492,493];
			// var gens = [1,152,252,387,494,650,722,766,Infinity];
			// kanto 1-151
			// johto 152-251
			// hoenn 252-386
			// sinnoh 387-493
			// unova 494-649
			// kalos 650-721
			// alola 722-809

			// var poke = _.filter(pokemon, p => _.includes(uncaught, p.dex));

			var gridColumns = [
				{ title: '', field: '', width: 50, headerFilter: false },
				{ title: 'Dex', field: 'dex', align: 'right' },
				{ title: 'Photo', field: 'photo', align: 'center', formatter: 'image', formatterParams: { height: '50px', width: '50px' } },
				{ title: 'Name', field: 'name' },
				{ title: 'Buddy', field: 'buddy', align: 'right', formatter: 'distance' },
				{ title: 'Max CP', field: 'maxCP', align: 'right' },
				{ title: 'Quick', field: 'quicks', formatter: 'moves' },
				{ title: 'Charge', field: 'charges', formatter: 'moves' },
				{ title: 'Family', field: 'family' },
				{ title: 'Attack', field: 'attack', align: 'right' },
				{ title: 'Defense', field: 'defense', align: 'right' },
				{ title: 'Stamina', field: 'stamina', align: 'right' },
				{ title: 'Flee', field: 'flee', align: 'right', formatter: 'percent' },
				{ title: 'Capture', field: 'capture', align: 'right', formatter: 'percent' },
				{ title: 'Male', field: 'male', align: 'right', formatter: 'percent' },
				{ title: 'Female', field: 'female', align: 'right', formatter: 'percent' },
				{ title: 'Rarity', field: 'rarity' },
				{ title: 'Types', field: 'types', formatter: 'types' },
				{ title: 'Category', field: 'category' },
				{ title: 'Description', field: 'description', width: 200 },
				{ title: 'Released', field: 'released', align: 'center', formatter: 'tickCross', formatterParams: { crossElement: false } },
				{ title: 'Ditto', field: 'ditto', align: 'center', formatter: 'tickCross', formatterParams: { crossElement: false } },
				{ title: 'Exclusive', field: 'exclusive' },
				{ title: 'Shiny', field: 'shiny' },
				{ title: 'Weather', field: 'weather', formatter: 'list' },
			];
			_.each(gridColumns, column => _.defaults(column, { headerFilter: true }));


			$(() => {

				var table = new Tabulator('#tabulator', {
					data: pokemon,
					columns: gridColumns,
					height: 300,
					dataTree: true, // BUG: if childField is null or empty array, still shows indicators
					dataTreeChildField: 'evolutions',
					// dataTreeElementColumn: 'name',  // BUG: if elementColumn is undefined, moving dataTree column moves indicators with it until you click on them individually
					// dataTreeChildIndent: 20, // BUG: if defined, resizing row to larger then smaller has issues
					movableColumns: true,
					headerFilterPlaceholder: 'filter...',
				});

			});


// var move: _.find(moves, { id: this.moveID })
// 		var monster = _.find(pokemon, { id: this.monsterID });
// 		var effects = _(this.monster.types)
// 			.map(type => _.find(types, { id: type.id }).damage)
// 			.flatten()
// 			.groupBy('id')
// 			.map((group, key) => ({
// 				// id: key,
// 				name:			_.find(types, { id: key }).name,
// 				attackScalar:	_.multiply.apply(null, _.map(group, 'attackScalar')).toFixed(3),
// 			}))
// 			.orderBy(['attackScalar', 'name'], ['desc', 'asc'])
// 			.groupBy('attackScalar')
// 			.value();



		</script>
	</head>

	<body>

		<div id="tabulator"></div>

	</body>
</html>
